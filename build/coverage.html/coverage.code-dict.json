{"/home/travis/build/npmtest/node-npmtest-twit/test.js":"/* istanbul instrument in package npmtest_twit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-twit/lib.npmtest_twit.js":"/* istanbul instrument in package npmtest_twit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_twit = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_twit = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-twit/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-twit && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_twit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_twit\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_twit.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_twit.rollup.js'] =\n            local.assetsDict['/assets.npmtest_twit.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_twit.__dirname +\n                    '/lib.npmtest_twit.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-twit/node_modules/twit/lib/twitter.js":"//\n//  Twitter API Wrapper\n//\nvar assert = require('assert');\nvar Promise = require('bluebird');\nvar request = require('request');\nvar util = require('util');\nvar endpoints = require('./endpoints');\nvar FileUploader = require('./file_uploader');\nvar helpers = require('./helpers');\nvar StreamingAPIConnection = require('./streaming-api-connection');\nvar STATUS_CODES_TO_ABORT_ON = require('./settings').STATUS_CODES_TO_ABORT_ON;\n\n// config values required for app-only auth\nvar required_for_app_auth = [\n  'consumer_key',\n  'consumer_secret'\n];\n\n// config values required for user auth (superset of app-only auth)\nvar required_for_user_auth = required_for_app_auth.concat([\n  'access_token',\n  'access_token_secret'\n]);\n\nvar FORMDATA_PATHS = [\n  'media/upload',\n  'account/update_profile_image',\n  'account/update_profile_background_image',\n];\n\nvar JSONPAYLOAD_PATHS = [\n  'media/metadata/create'\n]\n\n//\n//  Twitter\n//\nvar Twitter = function (config) {\n  if (!(this instanceof Twitter)) {\n    return new Twitter(config);\n  }\n\n  var self = this\n  var credentials = {\n    consumer_key        : config.consumer_key,\n    consumer_secret     : config.consumer_secret,\n    // access_token and access_token_secret only required for user auth\n    access_token        : config.access_token,\n    access_token_secret : config.access_token_secret,\n    // flag indicating whether requests should be made with application-only auth\n    app_only_auth       : config.app_only_auth,\n  }\n\n  this._validateConfigOrThrow(config);\n  this.config = config;\n  this._twitter_time_minus_local_time_ms = 0;\n}\n\nTwitter.prototype.get = function (path, params, callback) {\n  return this.request('GET', path, params, callback)\n}\n\nTwitter.prototype.post = function (path, params, callback) {\n  return this.request('POST', path, params, callback)\n}\n\nTwitter.prototype.request = function (method, path, params, callback) {\n  var self = this;\n  assert(method == 'GET' || method == 'POST');\n  // if no `params` is specified but a callback is, use default params\n  if (typeof params === 'function') {\n    callback = params\n    params = {}\n  }\n\n  return new Promise(function (resolve, reject) {\n    var _returnErrorToUser = function (err) {\n      if (callback && typeof callback === 'function') {\n        callback(err, null, null);\n      }\n      reject(err);\n    }\n\n    self._buildReqOpts(method, path, params, false, function (err, reqOpts) {\n      if (err) {\n        _returnErrorToUser(err);\n        return\n      }\n\n      var twitOptions = (params && params.twit_options) || {};\n\n      process.nextTick(function () {\n        // ensure all HTTP i/o occurs after the user has a chance to bind their event handlers\n        self._doRestApiRequest(reqOpts, twitOptions, method, function (err, parsedBody, resp) {\n          self._updateClockOffsetFromResponse(resp);\n\n          if (self.config.trusted_cert_fingerprints) {\n            if (!resp.socket.authorized) {\n              // The peer certificate was not signed by one of the authorized CA's.\n              var authErrMsg = resp.socket.authorizationError.toString();\n              var err = helpers.makeTwitError('The peer certificate was not signed; ' + authErrMsg);\n              _returnErrorToUser(err);\n              return;\n            }\n            var fingerprint = resp.socket.getPeerCertificate().fingerprint;\n            var trustedFingerprints = self.config.trusted_cert_fingerprints;\n            if (trustedFingerprints.indexOf(fingerprint) === -1) {\n              var errMsg = util.format('Certificate untrusted. Trusted fingerprints are: %s. Got fingerprint: %s.',\n                                       trustedFingerprints.join(','), fingerprint);\n              var err = new Error(errMsg);\n              _returnErrorToUser(err);\n              return;\n            }\n          }\n\n          if (callback && typeof callback === 'function') {\n            callback(err, parsedBody, resp);\n          }\n\n          resolve({ data: parsedBody, resp: resp });\n          return;\n        })\n      })\n    });\n  });\n}\n\n/**\n * Uploads a file to Twitter via the POST media/upload (chunked) API.\n * Use this as an easier alternative to doing the INIT/APPEND/FINALIZE commands yourself.\n * Returns the response from the FINALIZE command, or if an error occurs along the way,\n * the first argument to `cb` will be populated with a non-null Error.\n *\n *\n * `params` is an Object of the form:\n * {\n *   file_path: String // Absolute path of file to be uploaded.\n * }\n *\n * @param  {Object}  params  options object (described above).\n * @param  {cb}      cb      callback of the form: function (err, bodyObj, resp)\n */\nTwitter.prototype.postMediaChunked = function (params, cb) {\n  var self = this;\n  try {\n    var fileUploader = new FileUploader(params, self);\n  } catch(err) {\n    cb(err);\n    return;\n  }\n  fileUploader.upload(cb);\n}\n\nTwitter.prototype._updateClockOffsetFromResponse = function (resp) {\n  var self = this;\n  if (resp && resp.headers && resp.headers.date &&\n      new Date(resp.headers.date).toString() !== 'Invalid Date'\n  ) {\n    var twitterTimeMs = new Date(resp.headers.date).getTime()\n    self._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n  }\n}\n\n/**\n * Builds and returns an options object ready to pass to `request()`\n * @param  {String}   method      \"GET\" or \"POST\"\n * @param  {String}   path        REST API resource uri (eg. \"statuses/destroy/:id\")\n * @param  {Object}   params      user's params object\n * @param  {Boolean}  isStreaming Flag indicating if it's a request to the Streaming API (different endpoint)\n * @returns {Undefined}\n *\n * Calls `callback` with Error, Object where Object is an options object ready to pass to `request()`.\n *\n * Returns error raised (if any) by `helpers.moveParamsIntoPath()`\n */\nTwitter.prototype._buildReqOpts = function (method, path, params, isStreaming, callback) {\n  var self = this\n  if (!params) {\n    params = {}\n  }\n  // clone `params` object so we can modify it without modifying the user's reference\n  var paramsClone = JSON.parse(JSON.stringify(params))\n  // convert any arrays in `paramsClone` to comma-seperated strings\n  var finalParams = this.normalizeParams(paramsClone)\n  delete finalParams.twit_options\n\n  // the options object passed to `request` used to perform the HTTP request\n  var reqOpts = {\n    headers: {\n      'Accept': '*/*',\n      'User-Agent': 'twit-client'\n    },\n    gzip: true,\n    encoding: null,\n  }\n\n  if (typeof self.config.timeout_ms !== 'undefined') {\n    reqOpts.timeout = self.config.timeout_ms;\n  }\n\n  try {\n    // finalize the `path` value by building it using user-supplied params\n    path = helpers.moveParamsIntoPath(finalParams, path)\n  } catch (e) {\n    callback(e, null, null)\n    return\n  }\n\n  if (path.match(/^https?:\\/\\//i)) {\n    // This is a full url request\n    reqOpts.url = path\n  } else\n  if (isStreaming) {\n    // This is a Streaming API request.\n\n    var stream_endpoint_map = {\n      user: endpoints.USER_STREAM,\n      site: endpoints.SITE_STREAM\n    }\n    var endpoint = stream_endpoint_map[path] || endpoints.PUB_STREAM\n    reqOpts.url = endpoint + path + '.json'\n  } else {\n    // This is a REST API request.\n\n    if (path.indexOf('media/') !== -1) {\n      // For media/upload, use a different endpoint.\n      reqOpts.url = endpoints.MEDIA_UPLOAD + path + '.json';\n    } else {\n      reqOpts.url = endpoints.REST_ROOT + path + '.json';\n    }\n\n    if (FORMDATA_PATHS.indexOf(path) !== -1) {\n      reqOpts.headers['Content-type'] = 'multipart/form-data';\n      reqOpts.form = finalParams;\n       // set finalParams to empty object so we don't append a query string\n      // of the params\n      finalParams = {};\n    } else if (JSONPAYLOAD_PATHS.indexOf(path) !== -1) {\n      reqOpts.headers['Content-type'] = 'application/json';\n      reqOpts.json = true;\n      reqOpts.body = finalParams;\n      // as above, to avoid appending query string for body params\n      finalParams = {};\n    } else {\n      reqOpts.headers['Content-type'] = 'application/json';\n    }\n  }\n\n  if (Object.keys(finalParams).length) {\n    // not all of the user's parameters were used to build the request path\n    // add them as a query string\n    var qs = helpers.makeQueryString(finalParams)\n    reqOpts.url += '?' + qs\n  }\n\n  if (!self.config.app_only_auth) {\n    // with user auth, we can just pass an oauth object to requests\n    // to have the request signed\n    var oauth_ts = Date.now() + self._twitter_time_minus_local_time_ms;\n\n    reqOpts.oauth = {\n      consumer_key: self.config.consumer_key,\n      consumer_secret: self.config.consumer_secret,\n      token: self.config.access_token,\n      token_secret: self.config.access_token_secret,\n      timestamp: Math.floor(oauth_ts/1000).toString(),\n    }\n\n    callback(null, reqOpts);\n    return;\n  } else {\n    // we're using app-only auth, so we need to ensure we have a bearer token\n    // Once we have a bearer token, add the Authorization header and return the fully qualified `reqOpts`.\n    self._getBearerToken(function (err, bearerToken) {\n      if (err) {\n        callback(err, null)\n        return\n      }\n\n      reqOpts.headers['Authorization'] = 'Bearer ' + bearerToken;\n      callback(null, reqOpts)\n      return\n    })\n  }\n}\n\n/**\n * Make HTTP request to Twitter REST API.\n * @param  {Object}   reqOpts     options object passed to `request()`\n * @param  {Object}   twitOptions\n * @param  {String}   method      \"GET\" or \"POST\"\n * @param  {Function} callback    user's callback\n * @return {Undefined}\n */\nTwitter.prototype._doRestApiRequest = function (reqOpts, twitOptions, method, callback) {\n  var request_method = request[method.toLowerCase()];\n  var req = request_method(reqOpts);\n\n  var body = '';\n  var response = null;\n\n  var onRequestComplete = function () {\n    if (body !== '') {\n      try {\n        body = JSON.parse(body)\n      } catch (jsonDecodeError) {\n        // there was no transport-level error, but a JSON object could not be decoded from the request body\n        // surface this to the caller\n        var err = helpers.makeTwitError('JSON decode error: Twitter HTTP response body was not valid JSON')\n        err.statusCode = response ? response.statusCode: null;\n        err.allErrors.concat({error: jsonDecodeError.toString()})\n        callback(err, body, response);\n        return\n      }\n    }\n\n    if (typeof body === 'object' && (body.error || body.errors)) {\n      // we got a Twitter API-level error response\n      // place the errors in the HTTP response body into the Error object and pass control to caller\n      var err = helpers.makeTwitError('Twitter API Error')\n      err.statusCode = response ? response.statusCode: null;\n      helpers.attachBodyInfoToError(err, body);\n      callback(err, body, response);\n      return\n    }\n\n    // success case - no errors in HTTP response body\n    callback(err, body, response)\n  }\n\n  req.on('response', function (res) {\n    response = res\n    // read data from `request` object which contains the decompressed HTTP response body,\n    // `response` is the unmodified http.IncomingMessage object which may contain compressed data\n    req.on('data', function (chunk) {\n      body += chunk.toString('utf8')\n    })\n    // we're done reading the response\n    req.on('end', function () {\n      onRequestComplete()\n    })\n  })\n\n  req.on('error', function (err) {\n    // transport-level error occurred - likely a socket error\n    if (twitOptions.retry &&\n        STATUS_CODES_TO_ABORT_ON.indexOf(err.statusCode) !== -1\n    ) {\n      // retry the request since retries were specified and we got a status code we should retry on\n      self.request(method, path, params, callback);\n      return;\n    } else {\n      // pass the transport-level error to the caller\n      err.statusCode = null\n      err.code = null\n      err.allErrors = [];\n      helpers.attachBodyInfoToError(err, body)\n      callback(err, body, response);\n      return;\n    }\n  })\n}\n\n/**\n * Creates/starts a connection object that stays connected to Twitter's servers\n * using Twitter's rules.\n *\n * @param  {String} path   Resource path to connect to (eg. \"statuses/sample\")\n * @param  {Object} params user's params object\n * @return {StreamingAPIConnection}        [description]\n */\nTwitter.prototype.stream = function (path, params) {\n  var self = this;\n  var twitOptions = (params && params.twit_options) || {};\n\n  var streamingConnection = new StreamingAPIConnection()\n  self._buildReqOpts('POST', path, params, true, function (err, reqOpts) {\n    if (err) {\n      // we can get an error if we fail to obtain a bearer token or construct reqOpts\n      // surface this on the streamingConnection instance (where a user may register their error handler)\n      streamingConnection.emit('error', err)\n      return\n    }\n    // set the properties required to start the connection\n    streamingConnection.reqOpts = reqOpts\n    streamingConnection.twitOptions = twitOptions\n\n    process.nextTick(function () {\n      streamingConnection.start()\n    })\n  })\n\n  return streamingConnection\n}\n\n/**\n * Gets bearer token from cached reference on `self`, or fetches a new one and sets it on `self`.\n *\n * @param  {Function} callback Function to invoke with (Error, bearerToken)\n * @return {Undefined}\n */\nTwitter.prototype._getBearerToken = function (callback) {\n  var self = this;\n  if (self._bearerToken) {\n    return callback(null, self._bearerToken)\n  }\n\n  helpers.getBearerToken(self.config.consumer_key, self.config.consumer_secret,\n  function (err, bearerToken) {\n    if (err) {\n      // return the fully-qualified Twit Error object to caller\n      callback(err, null);\n      return;\n    }\n    self._bearerToken = bearerToken;\n    callback(null, self._bearerToken);\n    return;\n  })\n}\n\nTwitter.prototype.normalizeParams = function (params) {\n  var normalized = params\n  if (params && typeof params === 'object') {\n    Object.keys(params).forEach(function (key) {\n      var value = params[key]\n      // replace any arrays in `params` with comma-separated string\n      if (Array.isArray(value))\n        normalized[key] = value.join(',')\n    })\n  } else if (!params) {\n    normalized = {}\n  }\n  return normalized\n}\n\nTwitter.prototype.setAuth = function (auth) {\n  var self = this\n  var configKeys = [\n    'consumer_key',\n    'consumer_secret',\n    'access_token',\n    'access_token_secret'\n  ];\n\n  // update config\n  configKeys.forEach(function (k) {\n    if (auth[k]) {\n      self.config[k] = auth[k]\n    }\n  })\n  this._validateConfigOrThrow(self.config);\n}\n\nTwitter.prototype.getAuth = function () {\n  return this.config\n}\n\n//\n// Check that the required auth credentials are present in `config`.\n// @param {Object}  config  Object containing credentials for REST API auth\n//\nTwitter.prototype._validateConfigOrThrow = function (config) {\n  //check config for proper format\n  if (typeof config !== 'object') {\n    throw new TypeError('config must be object, got ' + typeof config)\n  }\n\n  if (typeof config.timeout_ms !== 'undefined' && isNaN(Number(config.timeout_ms))) {\n    throw new TypeError('Twit config `timeout_ms` must be a Number. Got: ' + config.timeout_ms + '.');\n  }\n\n  if (config.app_only_auth) {\n    var auth_type = 'app-only auth'\n    var required_keys = required_for_app_auth\n  } else {\n    var auth_type = 'user auth'\n    var required_keys = required_for_user_auth\n  }\n\n  required_keys.forEach(function (req_key) {\n    if (!config[req_key]) {\n      var err_msg = util.format('Twit config must include `%s` when using %s.', req_key, auth_type)\n      throw new Error(err_msg)\n    }\n  })\n}\n\nmodule.exports = Twitter\n","/home/travis/build/npmtest/node-npmtest-twit/node_modules/twit/lib/endpoints.js":"//  Twitter Endpoints\nmodule.exports = {\n    API_HOST      : 'https://api.twitter.com/'\n  , REST_ROOT     : 'https://api.twitter.com/1.1/'\n  , PUB_STREAM    : 'https://stream.twitter.com/1.1/'\n  , USER_STREAM   : 'https://userstream.twitter.com/1.1/'\n  , SITE_STREAM   : 'https://sitestream.twitter.com/1.1/'\n  , MEDIA_UPLOAD  : 'https://upload.twitter.com/1.1/'\n  , OA_REQ        : 'https://api.twitter.com/oauth/request_token'\n  , OA_ACCESS     : 'https://api.twitter.com/oauth/access_token'\n}","/home/travis/build/npmtest/node-npmtest-twit/node_modules/twit/lib/file_uploader.js":"var assert = require('assert');\nvar fs = require('fs');\nvar mime = require('mime');\nvar util = require('util');\n\nvar MAX_FILE_SIZE_BYTES = 15 * 1024 * 1024;\nvar MAX_FILE_CHUNK_BYTES = 5 * 1024 * 1024;\n\n/**\n * FileUploader class used to upload a file to twitter via the /media/upload (chunked) API.\n * Usage:\n *   var fu = new FileUploader({ file_path: '/foo/bar/baz.mp4' }, twit);\n *   fu.upload(function (err, bodyObj, resp) {\n *     console.log(err, bodyObj);\n *   })\n *\n * @param  {Object}         params  Object of the form { file_path: String }.\n * @param  {Twit(object)}   twit    Twit instance.\n */\nvar FileUploader = function (params, twit) {\n  assert(params)\n  assert(params.file_path, 'Must specify `file_path` to upload a file. Got: ' + params.file_path + '.')\n  var self = this;\n  self._file_path = params.file_path;\n  self._twit = twit;\n  self._isUploading = false;\n  self._isFileStreamEnded = false;\n}\n\n/**\n * Upload a file to Twitter via the /media/upload (chunked) API.\n *\n * @param  {Function} cb function (err, data, resp)\n */\nFileUploader.prototype.upload = function (cb) {\n  var self = this;\n\n  // Send INIT command with file info and get back a media_id_string we can use to APPEND chunks to it.\n  self._initMedia(function (err, bodyObj, resp) {\n    if (err) {\n      cb(err);\n      return;\n    } else {\n      var mediaTmpId = bodyObj.media_id_string;\n      var chunkNumber = 0;\n      var mediaFile = fs.createReadStream(self._file_path, { highWatermark: MAX_FILE_CHUNK_BYTES });\n\n      mediaFile.on('data', function (chunk) {\n        // Pause our file stream from emitting `data` events until the upload of this chunk completes.\n        // Any data that becomes available will remain in the internal buffer.\n        mediaFile.pause();\n        self._isUploading = true;\n\n        self._appendMedia(mediaTmpId, chunk.toString('base64'), chunkNumber, function (err, bodyObj, resp) {\n          self._isUploading = false;\n          if (err) {\n            cb(err);\n          } else {\n            if (self._isUploadComplete()) {\n              // We've hit the end of our stream; send FINALIZE command.\n              self._finalizeMedia(mediaTmpId, cb);\n            } else {\n              // Tell our file stream to start emitting `data` events again.\n              chunkNumber++;\n              mediaFile.resume();\n            }\n          }\n        });\n      });\n\n      mediaFile.on('end', function () {\n        // Mark our file streaming complete, and if done, send FINALIZE command.\n        self._isFileStreamEnded = true;\n        if (self._isUploadComplete()) {\n          self._finalizeMedia(mediaTmpId, cb);\n        }\n      });\n    }\n  })\n}\n\nFileUploader.prototype._isUploadComplete = function () {\n  return !this._isUploading && this._isFileStreamEnded;\n}\n\n  /**\n   * Send FINALIZE command for media object with id `media_id`.\n   *\n   * @param  {String}   media_id\n   * @param  {Function} cb\n   */\nFileUploader.prototype._finalizeMedia = function(media_id, cb) {\n  var self = this;\n  self._twit.post('media/upload', {\n    command: 'FINALIZE',\n    media_id: media_id\n  }, cb);\n}\n\n  /**\n   * Send APPEND command for media object with id `media_id`.\n   * Append the chunk to the media object, then resume streaming our mediaFile.\n   *\n   * @param  {String}   media_id        media_id_string received from Twitter after sending INIT comand.\n   * @param  {String}   chunk_part      Base64-encoded String chunk of the media file.\n   * @param  {Number}   segment_index   Index of the segment.\n   * @param  {Function} cb\n   */\nFileUploader.prototype._appendMedia = function(media_id_string, chunk_part, segment_index, cb) {\n  var self = this;\n  self._twit.post('media/upload', {\n    command: 'APPEND',\n    media_id: media_id_string.toString(),\n    segment_index: segment_index,\n    media: chunk_part,\n  }, cb);\n}\n\n/**\n * Send INIT command for our underlying media object.\n *\n * @param  {Function} cb\n */\nFileUploader.prototype._initMedia = function (cb) {\n  var self = this;\n  var mediaType = mime.lookup(self._file_path);\n  var mediaFileSizeBytes = fs.statSync(self._file_path).size;\n\n  // Check the file size - it should not go over 15MB for video.\n  // See https://dev.twitter.com/rest/reference/post/media/upload-chunked\n  if (mediaFileSizeBytes < MAX_FILE_SIZE_BYTES) {\n    self._twit.post('media/upload', {\n      'command': 'INIT',\n      'media_type': mediaType,\n      'total_bytes': mediaFileSizeBytes\n    }, cb);\n  } else {\n    var errMsg = util.format('This file is too large. Max size is %dB. Got: %dB.', MAX_FILE_SIZE_BYTES, mediaFileSizeBytes);\n    cb(new Error(errMsg));\n  }\n}\n\nmodule.exports = FileUploader\n","/home/travis/build/npmtest/node-npmtest-twit/node_modules/twit/lib/helpers.js":"var querystring = require('querystring');\nvar request = require('request');\n\nvar endpoints = require('./endpoints');\n\n/**\n * Encodes object as a querystring, to be used as the suffix of request URLs.\n * @param  {Object} obj\n * @return {String}\n */\nexports.makeQueryString = function (obj) {\n  var qs = querystring.stringify(obj)\n  qs = qs.replace(/\\!/g, \"%21\")\n         .replace(/\\'/g, \"%27\")\n         .replace(/\\(/g, \"%28\")\n         .replace(/\\)/g, \"%29\")\n         .replace(/\\*/g, \"%2A\");\n  return qs\n}\n\n/**\n * For each `/:param` fragment in path, move the value in params\n * at that key to path. If the key is not found in params, throw.\n * Modifies both params and path values.\n *\n * @param  {Objet} params  Object used to build path.\n * @param  {String} path   String to transform.\n * @return {Undefined}\n *\n */\nexports.moveParamsIntoPath = function (params, path) {\n  var rgxParam = /\\/:(\\w+)/g\n  var missingParamErr = null\n\n  path = path.replace(rgxParam, function (hit) {\n    var paramName = hit.slice(2)\n    var suppliedVal = params[paramName]\n    if (!suppliedVal) {\n      throw new Error('Twit: Params object is missing a required parameter for this request: `'+paramName+'`')\n    }\n    var retVal = '/' + suppliedVal\n    delete params[paramName]\n    return retVal\n  })\n  return path\n}\n\n/**\n * When Twitter returns a response that looks like an error response,\n * use this function to attach the error info in the response body to `err`.\n *\n * @param  {Error} err   Error instance to which body info will be attached\n * @param  {Object} body JSON object that is the deserialized HTTP response body received from Twitter\n * @return {Undefined}\n */\nexports.attachBodyInfoToError = function (err, body) {\n  err.twitterReply = body;\n  if (!body) {\n    return\n  }\n  if (body.error) {\n    // the body itself is an error object\n    err.message = body.error\n    err.allErrors = err.allErrors.concat([body])\n  } else if (body.errors && body.errors.length) {\n    // body contains multiple error objects\n    err.message = body.errors[0].message;\n    err.code = body.errors[0].code;\n    err.allErrors = err.allErrors.concat(body.errors)\n  }\n}\n\nexports.makeTwitError = function (message) {\n  var err = new Error()\n  if (message) {\n    err.message = message\n  }\n  err.code = null\n  err.allErrors = []\n  err.twitterReply = null\n  return err\n}\n\n/**\n * Get a bearer token for OAuth2\n * @param  {String}   consumer_key\n * @param  {String}   consumer_secret\n * @param  {Function} cb\n *\n * Calls `cb` with Error, String\n *\n * Error (if it exists) is guaranteed to be Twit error-formatted.\n * String (if it exists) is the bearer token received from Twitter.\n */\nexports.getBearerToken = function (consumer_key, consumer_secret, cb) {\n  // use OAuth 2 for app-only auth (Twitter requires this)\n  // get a bearer token using our app's credentials\n  var b64Credentials = new Buffer(consumer_key + ':' + consumer_secret).toString('base64');\n  request.post({\n    url: endpoints.API_HOST + '/oauth2/token',\n    headers: {\n      'Authorization': 'Basic ' + b64Credentials,\n      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'\n    },\n    body: 'grant_type=client_credentials',\n    json: true,\n  }, function (err, res, body) {\n    if (err) {\n      var error = exports.makeTwitError(err.toString());\n      exports.attachBodyInfoToError(error, body);\n      return cb(error, body, res);\n    }\n    \n    if ( !body ) {\n      var error = exports.makeTwitError('Not valid reply from Twitter upon obtaining bearer token');\n      exports.attachBodyInfoToError(error, body);\n      return cb(error, body, res);\n    }\n\n    if (body.token_type !== 'bearer') {\n      var error = exports.makeTwitError('Unexpected reply from Twitter upon obtaining bearer token');\n      exports.attachBodyInfoToError(error, body);\n      return cb(error, body, res);\n    }\n\n    return cb(err, body.access_token);\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-twit/node_modules/twit/lib/streaming-api-connection.js":"\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar helpers = require('./helpers')\nvar Parser = require('./parser');\nvar request = require('request');\nvar zlib = require('zlib');\n\nvar STATUS_CODES_TO_ABORT_ON = require('./settings').STATUS_CODES_TO_ABORT_ON\n\nvar StreamingAPIConnection = function (reqOpts, twitOptions) {\n  this.reqOpts = reqOpts\n  this.twitOptions = twitOptions\n  this._twitter_time_minus_local_time_ms = 0\n  EventEmitter.call(this)\n}\n\nutil.inherits(StreamingAPIConnection, EventEmitter)\n\n/**\n * Resets the connection.\n * - clears request, response, parser\n * - removes scheduled reconnect handle (if one was scheduled)\n * - stops the stall abort timeout handle (if one was scheduled)\n */\nStreamingAPIConnection.prototype._resetConnection = function () {\n  if (this.request) {\n    // clear our reference to the `request` instance\n    this.request.removeAllListeners();\n    this.request.destroy();\n  }\n\n  if (this.response) {\n    // clear our reference to the http.IncomingMessage instance\n    this.response.removeAllListeners();\n    this.response.destroy();\n  }\n\n  if (this.parser) {\n    this.parser.removeAllListeners()\n  }\n\n  // ensure a scheduled reconnect does not occur (if one was scheduled)\n  // this can happen if we get a close event before .stop() is called\n  clearTimeout(this._scheduledReconnect)\n  delete this._scheduledReconnect\n\n  // clear our stall abort timeout\n  this._stopStallAbortTimeout()\n}\n\n/**\n * Resets the parameters used in determining the next reconnect time\n */\nStreamingAPIConnection.prototype._resetRetryParams = function () {\n  // delay for next reconnection attempt\n  this._connectInterval = 0\n  // flag indicating whether we used a 0-delay reconnect\n  this._usedFirstReconnect = false\n}\n\nStreamingAPIConnection.prototype._startPersistentConnection = function () {\n  var self = this;\n  self._resetConnection();\n  self._setupParser();\n  self._resetStallAbortTimeout();\n  self._setOauthTimestamp();\n  self.request = request.post(this.reqOpts);\n  self.emit('connect', self.request);\n  self.request.on('response', function (response) {\n    self._updateOauthTimestampOffsetFromResponse(response)\n    // reset our reconnection attempt flag so next attempt goes through with 0 delay\n    // if we get a transport-level error\n    self._usedFirstReconnect = false;\n    // start a stall abort timeout handle\n    self._resetStallAbortTimeout();\n    self.response = response\n    if (STATUS_CODES_TO_ABORT_ON.indexOf(self.response.statusCode) !== -1) {\n      // We got a status code telling us we should abort the connection.\n      // Read the body from the response and return an error to the user.\n      var body = '';\n      var compressedBody = '';\n\n      self.response.on('data', function (chunk) {\n        compressedBody += chunk.toString('utf8');\n      })\n\n      var gunzip = zlib.createGunzip();\n      self.response.pipe(gunzip);\n      gunzip.on('data', function (chunk) {\n        body += chunk.toString('utf8')\n      })\n\n      gunzip.on('end', function () {\n        try {\n          body = JSON.parse(body)\n        } catch (jsonDecodeError) {\n          // Twitter may send an HTML body\n          // if non-JSON text was returned, we'll just attach it to the error as-is\n        }\n        // surface the error to the user\n        var error = helpers.makeTwitError('Bad Twitter streaming request: ' + self.response.statusCode)\n        error.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(error, body)\n        self.emit('error', error);\n        // stop the stream explicitly so we don't reconnect\n        self.stop()\n        body = null;\n      });\n      gunzip.on('error', function (err) {\n        // If Twitter sends us back an uncompressed HTTP response, gzip will error out.\n        // Handle this by emitting an error with the uncompressed response body.\n        var errMsg = 'Gzip error: ' + err.message;\n        var twitErr = helpers.makeTwitError(errMsg);\n        twitErr.statusCode = self.response.statusCode;\n        helpers.attachBodyInfoToError(twitErr, compressedBody);\n        self.emit('parser-error', twitErr);\n      });\n    } else if (self.response.statusCode === 420) {\n      // close the connection forcibly so a reconnect is scheduled by `self.onClose()`\n      self._scheduleReconnect();\n    } else {\n      // We got an OK status code - the response should be valid.\n      // Read the body from the response and return to the user.\n      var gunzip = zlib.createGunzip();\n      self.response.pipe(gunzip);\n\n      //pass all response data to parser\n      gunzip.on('data', function (chunk) {\n        self._connectInterval = 0\n        // stop stall timer, and start a new one\n        self._resetStallAbortTimeout();\n        self.parser.parse(chunk.toString('utf8'));\n      });\n\n      gunzip.on('close', self._onClose.bind(self))\n      gunzip.on('error', function (err) {\n        self.emit('error', err);\n      })\n      self.response.on('error', function (err) {\n        // expose response errors on twit instance\n        self.emit('error', err);\n      })\n\n      // connected without an error response from Twitter, emit `connected` event\n      // this must be emitted after all its event handlers are bound\n      // so the reference to `self.response` is not interfered-with by the user until it is emitted\n      self.emit('connected', self.response);\n    }\n  });\n  self.request.on('close', self._onClose.bind(self));\n  self.request.on('error', function (err) { self._scheduleReconnect.bind(self) });\n  return self;\n}\n\n/**\n * Handle when the request or response closes.\n * Schedule a reconnect according to Twitter's reconnect guidelines\n *\n */\nStreamingAPIConnection.prototype._onClose = function () {\n  var self = this;\n  self._stopStallAbortTimeout();\n  if (self._scheduledReconnect) {\n    // if we already have a reconnect scheduled, don't schedule another one.\n    // this race condition can happen if the http.ClientRequest and http.IncomingMessage both emit `close`\n    return\n  }\n\n  self._scheduleReconnect();\n}\n\n/**\n * Kick off the http request, and persist the connection\n *\n */\nStreamingAPIConnection.prototype.start = function () {\n  this._resetRetryParams();\n  this._startPersistentConnection();\n  return this;\n}\n\n/**\n * Abort the http request, stop scheduled reconnect (if one was scheduled) and clear state\n *\n */\nStreamingAPIConnection.prototype.stop = function () {\n  // clear connection variables and timeout handles\n  this._resetConnection();\n  this._resetRetryParams();\n  return this;\n}\n\n/**\n * Stop and restart the stall abort timer (called when new data is received)\n *\n * If we go 90s without receiving data from twitter, we abort the request & reconnect.\n */\nStreamingAPIConnection.prototype._resetStallAbortTimeout = function () {\n  var self = this;\n  // stop the previous stall abort timer\n  self._stopStallAbortTimeout();\n  //start a new 90s timeout to trigger a close & reconnect if no data received\n  self._stallAbortTimeout = setTimeout(function () {\n    self._scheduleReconnect()\n  }, 90000);\n  return this;\n}\n\n/**\n * Stop stall timeout\n *\n */\nStreamingAPIConnection.prototype._stopStallAbortTimeout = function () {\n  clearTimeout(this._stallAbortTimeout);\n  // mark the timer as `null` so it is clear via introspection that the timeout is not scheduled\n  delete this._stallAbortTimeout;\n  return this;\n}\n\n/**\n * Computes the next time a reconnect should occur (based on the last HTTP response received)\n * and starts a timeout handle to begin reconnecting after `self._connectInterval` passes.\n *\n * @return {Undefined}\n */\nStreamingAPIConnection.prototype._scheduleReconnect = function () {\n  var self = this;\n  if (self.response && self.response.statusCode === 420) {\n    // we are being rate limited\n    // start with a 1 minute wait and double each attempt\n    if (!self._connectInterval) {\n      self._connectInterval = 60000;\n    } else {\n      self._connectInterval *= 2;\n    }\n  } else if (self.response && String(self.response.statusCode).charAt(0) === '5') {\n    // twitter 5xx errors\n    // start with a 5s wait, double each attempt up to 320s\n    if (!self._connectInterval) {\n      self._connectInterval = 5000;\n    } else if (self._connectInterval < 320000) {\n      self._connectInterval *= 2;\n    } else {\n      self._connectInterval = 320000;\n    }\n  } else {\n    // we did not get an HTTP response from our last connection attempt.\n    // DNS/TCP error, or a stall in the stream (and stall timer closed the connection)\n    if (!self._usedFirstReconnect) {\n      // first reconnection attempt on a valid connection should occur immediately\n      self._connectInterval = 0;\n      self._usedFirstReconnect = true;\n    } else if (self._connectInterval < 16000) {\n      // linearly increase delay by 250ms up to 16s\n      self._connectInterval += 250;\n    } else {\n      // cap out reconnect interval at 16s\n      self._connectInterval = 16000;\n    }\n  }\n\n  // schedule the reconnect\n  self._scheduledReconnect = setTimeout(function () {\n    self._startPersistentConnection();\n  }, self._connectInterval);\n  self.emit('reconnect', self.request, self.response, self._connectInterval);\n}\n\nStreamingAPIConnection.prototype._setupParser = function () {\n  var self = this\n  self.parser = new Parser()\n\n  // handle twitter objects as they come in - emit the generic `message` event\n  // along with the specific event corresponding to the message\n  self.parser.on('element', function (msg) {\n    self.emit('message', msg)\n\n    if      (msg.delete)          { self.emit('delete', msg) }\n    else if (msg.disconnect)      { self._handleDisconnect(msg) }\n    else if (msg.limit)           { self.emit('limit', msg) }\n    else if (msg.scrub_geo)       { self.emit('scrub_geo', msg) }\n    else if (msg.warning)         { self.emit('warning', msg) }\n    else if (msg.status_withheld) { self.emit('status_withheld', msg) }\n    else if (msg.user_withheld)   { self.emit('user_withheld', msg) }\n    else if (msg.friends || msg.friends_str) { self.emit('friends', msg) }\n    else if (msg.direct_message)  { self.emit('direct_message', msg) }\n    else if (msg.event)           {\n      self.emit('user_event', msg)\n      // reference: https://dev.twitter.com/docs/streaming-apis/messages#User_stream_messages\n      var ev = msg.event\n\n      if      (ev === 'blocked')                { self.emit('blocked', msg) }\n      else if (ev === 'unblocked')              { self.emit('unblocked', msg) }\n      else if (ev === 'favorite')               { self.emit('favorite', msg) }\n      else if (ev === 'unfavorite')             { self.emit('unfavorite', msg) }\n      else if (ev === 'follow')                 { self.emit('follow', msg) }\n      else if (ev === 'unfollow')               { self.emit('unfollow', msg) }\n      else if (ev === 'mute')                   { self.emit('mute', msg) }\n      else if (ev === 'unmute')                 { self.emit('unmute', msg) }\n      else if (ev === 'user_update')            { self.emit('user_update', msg) }\n      else if (ev === 'list_created')           { self.emit('list_created', msg) }\n      else if (ev === 'list_destroyed')         { self.emit('list_destroyed', msg) }\n      else if (ev === 'list_updated')           { self.emit('list_updated', msg) }\n      else if (ev === 'list_member_added')      { self.emit('list_member_added', msg) }\n      else if (ev === 'list_member_removed')    { self.emit('list_member_removed', msg) }\n      else if (ev === 'list_user_subscribed')   { self.emit('list_user_subscribed', msg) }\n      else if (ev === 'list_user_unsubscribed') { self.emit('list_user_unsubscribed', msg) }\n      else if (ev === 'quoted_tweet')           { self.emit('quoted_tweet', msg) }\n      else if (ev === 'favorited_retweet')      { self.emit('favorited_retweet', msg) }\n      else if (ev === 'retweeted_retweet')      { self.emit('retweeted_retweet', msg) }\n      else                                      { self.emit('unknown_user_event', msg) }\n    } else                                      { self.emit('tweet', msg) }\n  })\n\n  self.parser.on('error', function (err) {\n    self.emit('parser-error', err)\n  });\n  self.parser.on('connection-limit-exceeded', function (err) {\n    self.emit('error', err);\n  })\n}\n\nStreamingAPIConnection.prototype._handleDisconnect = function (twitterMsg) {\n  this.emit('disconnect', twitterMsg);\n  this.stop();\n}\n\n/**\n * Call whenever an http request is about to be made to update\n * our local timestamp (used for Oauth) to be Twitter's server time.\n *\n */\nStreamingAPIConnection.prototype._setOauthTimestamp = function () {\n  var self = this;\n  if (self.reqOpts.oauth) {\n    var oauth_ts = Date.now() + self._twitter_time_minus_local_time_ms;\n    self.reqOpts.oauth.timestamp = Math.floor(oauth_ts/1000).toString();\n  }\n}\n\n/**\n * Call whenever an http response is received from Twitter,\n * to set our local timestamp offset from Twitter's server time.\n * This is used to set the Oauth timestamp for our next http request\n * to Twitter (by calling _setOauthTimestamp).\n *\n * @param  {http.IncomingResponse} resp   http response received from Twitter.\n */\nStreamingAPIConnection.prototype._updateOauthTimestampOffsetFromResponse = function (resp) {\n  if (resp && resp.headers && resp.headers.date &&\n      new Date(resp.headers.date).toString() !== 'Invalid Date'\n  ) {\n    var twitterTimeMs = new Date(resp.headers.date).getTime()\n    this._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n  }\n}\n\nmodule.exports = StreamingAPIConnection\n","/home/travis/build/npmtest/node-npmtest-twit/node_modules/twit/lib/parser.js":"//\n//  Parser - for Twitter Streaming API\n//\nvar util = require('util')\n  , EventEmitter = require('events').EventEmitter;\n\nvar Parser = module.exports = function ()  {\n  this.message = ''\n\n  EventEmitter.call(this);\n};\n\nutil.inherits(Parser, EventEmitter);\n\nParser.prototype.parse = function (chunk) {\n  this.message += chunk;\n  chunk = this.message;\n\n  var size = chunk.length\n    , start = 0\n    , offset = 0\n    , curr\n    , next;\n\n  while (offset < size) {\n    curr = chunk[offset];\n    next = chunk[offset + 1];\n\n    if (curr === '\\r' && next === '\\n') {\n      var piece = chunk.slice(start, offset);\n      start = offset += 2;\n\n      if (!piece.length) { continue; } //empty object\n\n      if (piece === 'Exceeded connection limit for user') {\n        this.emit('connection-limit-exceeded',\n                  new Error('Twitter says: ' + piece + '. Only instantiate one stream per set of credentials.'));\n        continue;\n      }\n\n      try {\n        var msg = JSON.parse(piece)\n      } catch (err) {\n        this.emit('error', new Error('Error parsing twitter reply: `'+piece+'`, error message `'+err+'`'));\n      } finally {\n        if (msg)\n          this.emit('element', msg)\n\n        continue\n      }\n    }\n    offset++;\n  }\n\n  this.message = chunk.slice(start, size);\n};\n","/home/travis/build/npmtest/node-npmtest-twit/node_modules/twit/lib/settings.js":"// set of status codes where we don't attempt reconnecting to Twitter\nexports.STATUS_CODES_TO_ABORT_ON = [ 400, 401, 403, 404, 406, 410, 422 ];"}